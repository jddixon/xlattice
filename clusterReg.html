<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>clusterReg</title>
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href="css/main.css" />
  <link rel="stylesheet" type="text/css" href="css/normalize.css" />
  <link rel="stylesheet" type="text/css" href="css/ghp.css" />
</head>
<body>
<div class="content">
<h1 class="libTop">xlReg Cluster Registry</h1>

<p>As the term is used here, an xLattice <strong>registry</strong> is a protocol for
communicating
between parties in a traditional server/client relationship.  On the
one hand we have independent
<a href="https://jddixon.github.io/xlattice/node.html">xLattice nodes</a>
which may cooperate as an
<a href="https://jddixon.github.io/xlattice/cluster.html">xLattice cluster,</a>
a collection of <strong>peers</strong> that communicate with one another over links
dedicated to this purpose.  On the other hand we have a single xlReg server
which is identified by its
<a href="https://jddixon.github.io/xlattice/node.html">NodeID</a>
(a 20- or 32-byte value).  The
server has a well-known address, a tcp/ip port in an address region
(an
<a href="https://jddixon.github.io/xlattice/overlay.html">overlay</a>
), accessible to the nodes wishing to form the cluster.  The
xlReg server also has two well-known RSA public keys, one (<strong>ck</strong>) for
use in encrypting data and the other (<strong>sk</strong>) for use in creating
digital signatures.</p>

<p>Clients join a cluster by sending a <code>Hello</code> message to the server to agree
on communications and then send an encrypted <code>Join</code> message with their
details.</p>

<p><img src="img/xl-registration.jpg" alt="xl-registration" style="float:right"></p>

<p>The <code>Hello</code> is encrypted using the server&rsquo;s RSA public key.  It contains a
salt (<code>salt1</code>), a requested version number, and an AES IV and key (<code>keyIV</code>)
used only to encrypt the reply, the <code>HelloReply</code>.  This iv+key is created by
the client and used once and once only by the server.</p>

<p>The <code>HelloReply</code> contains the original salt, another salt (<code>salt2</code>), the
protocol version to be used, and the AES IV and key (<code>keyIV2</code>) used for
the rest of the session.   By deciphering the first salt, the server has
proved its identity - that is, it has proved that it has the secret RSA
key corresponding to the public key.  If the <code>Hello</code> is in some way ill-formed,
the server will silently close the connection.  The client will do the same
if the <code>HelloReply</code> is not properly encrypted using <code>keyIV</code> or does not contain
the correct value for the salt.  From this point <code>keyIV2</code> is used by both sides
to encrypt session traffic.</p>

<p>The version number is currently ignored.  The expectation is that
at some point the version number in the <code>Hello</code> will be that requested by
the client and the version number in the reply will be that actually used
by the server.</p>

<p><img src="img/simple-cluster.jpg" alt="simple-cluster" style="float:left"></p>

<p>In the next step the client sends a Client message with either a proposed
clientName and a token or a clientID and salt2 from the <code>HelloReply</code>.  In the
first case the token will contain, among other things, a proposed
Attrs bit string.  In either case the message is signed using the
client&rsquo;s public key for signatures.  The server replies with a <code>ClientOK</code>
message or an error message.  The <code>ClientOK</code> contains a possibly
uniquified clientName, the actual clientID, and a possibly modified Attrs
bit string, the value that the server will use from this point forward.</p>

<p>At this point the client can send either a <code>Create</code> message, a <code>Join</code>, a
<code>Get</code>, or a <code>Bye</code>.</p>

<p>The <code>Create</code> message contains a cluster name and client-proposed size.
The server returns a <code>Create</code> reply which contains the cluster ID, its
possibly uniquified name, and its actual size.  If the cluster did
not previously exist, this message will create it with the size proposed,
but constrained to be in the range 2 .. 64 inclusive.  If the cluster
already exists, the proposed size is ignored.</p>

<p>A <code>Create</code> can be used simply to get the <code>clusterID</code> and size of an existing
cluster.</p>

<p>The cluster size is the maximum number of clients that will be allowed
to join the cluster.  It does not change as members join.</p>

<p>The <code>Join</code> message contains a clusterName or ID.  The server returns
either <code>clusterID</code> and size or an error message.</p>

<p>A <code>Get</code> message may contain a <code>clusterID</code> or a <code>Which</code> field, which indicates
which member descriptions (tokens) are requested.  The server will
return either an error message or a <code>Members</code> message containing a
<code>clusterID</code>, a <code>Which</code> field identifying the members whose information
follows, and a list (an array) of member tokens.</p>

<p>If the <code>clusterID</code> is not present, the server will assume the ID associated
with any previous <code>Create</code> or <code>Join</code>.</p>

<p><img src="img/cluster-with-clients.jpg" alt="cluster-with-clients" style="float:right"></p>

<p>If the <code>Which</code> field is present, the server will return tokens for the Nth
member wherever bit <code>N</code> is set in <code>Which</code>.  If <code>Which</code> is absent, the server
will act as though all possible <code>Which</code> bits are set.  In any case, the
server will return a token wherever the corresponding member has been
defined, and then will return a <code>Which</code> value indicating which tokens are
present.</p>

<p>The first token in the <code>Members</code> message will correspond to the lowest bit
set, any second bit to the second lowest bit, and so forth.  If no one
has joined the cluster or none of the selected members is as yet defined,
the <code>Which</code> field will be zero.</p>

<p>Clients can make any number of <code>Get</code> requests.  The normal behavior will
be to poll until the client has tokens for all cluster members.
Alternatively the client can close the connection and return later.</p>

<p>The client ends a session by sending <code>Bye</code> to the server.  The server
replies with an <code>Ack</code> and closes the connection.</p>

<p>Error messages from the server contain a string describing the problem.
The server will send the message and then close the connection without
waiting for a reply.</p>

<p>Look <a href="xlReg_protocol.html">here</a> for a more detailed description of the
xlReg protocol.</p>
  <div class="f">
    <hr />
    <div class="license">
      <p><a href="LICENSE-MIT.html">SOFTWARE LICENSE</a></p>
    </div>
    <div class="project">
      github <a href="https://github.com/jddixon/clusterReg">      <img src="img/GitHub-Mark-32px.png" 
        alt="link to project"  
        style="display: inline-block; margin-left: 0 auto; margin-right: 0 auto">
       </a> project
    </div>
    <div class="logo" >
      <a href="https://jddixon.github.io/xlattice/">
      <img src="img/xlattice-2014.jpg" alt="the XLattice Project" style="float: right;" >
      </a>
    </div>
  </div>
</div>
</body>
</html>
